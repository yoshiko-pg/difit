export interface GeneratedCheckResult {
  isGenerated: boolean;
  reason?: 'path' | 'universal' | 'language-specific';
  matchedPattern?: string;
}

// Layer 1: Path/Filename Patterns
const PATH_PATTERNS: RegExp[] = [
  // Lock files (all languages)
  /package-lock\.json$/,
  /pnpm-lock\.yaml$/,
  /yarn\.lock$/,
  /Gemfile\.lock$/,
  /Pipfile\.lock$/,
  /composer\.lock$/,
  /Cargo\.lock$/,
  /poetry\.lock$/,
  /go\.sum$/,
  /go\.mod$/,
  /pubspec\.lock$/,
  /flake\.lock$/,
  /Package\.resolved$/,
  /packages\.lock\.json$/,
  /\.terraform\.lock\.hcl$/,
  /bun\.lockb$/,
  /gradle\.lockfile$/,
  /uv\.lock$/,
  /pdm\.lock$/,

  // Minified / Bundled
  /\.min\.(js|css)$/,
  /\.bundle\.(js|css)$/,
  /-min\.js$/,
  /\.map$/,

  // Generated naming conventions
  /\.generated\.\w+$/,
  /\.gen\.\w+$/,
  /\.pb\.(go|rb|py|js|cc|h)$/, // protobuf
  /\.pb2\.py$/, // protobuf python
  /_pb2\.py$/,
  /\.grpc\.pb\.go$/,
  /_string\.go$/, // go generate stringer
  /\.graphql\.(ts|js)$/, // GraphQL codegen
  /\.openapi\.(ts|js)$/,
  /mock_.*\.go$/, // mockgen
  /mocks\/.*\.go$/,
  /\.msw\.ts$/,
  /\.zod\.ts$/,
  /\.api\.ts$/,
  /\.g\.dart$/,
  /\.freezed\.dart$/,
  /\.g\.cs$/,
  /\.designer\.cs$/,
  /_ide_helper\.php$/,

  // Directories
  /^vendor\//,
  /^node_modules\//,
  /^(dist|build|out)\//,
  /\/generated\//,
  /\/gen\//,
  /\/__generated__\//, // Relay
];

// Layer 2: Universal Header Patterns
const UNIVERSAL_PATTERNS: RegExp[] = [
  // Most common markers
  /@generated\b/,
  /\bDO NOT EDIT\b/i,
  /\bDO NOT MODIFY\b/i,
  /\bAUTO[- ]?GENERATED\b/i,
  /\bTHIS FILE IS GENERATED\b/i,
  /\bGENERATED CODE\b/i,
  /\bMACHINE GENERATED\b/i,

  // Common tool output phrases
  /Generated by\b/i,
  /Autogenerated by\b/i,
  /Created by .* - DO NOT EDIT/i,
  /This file was generated/i,
  /This is a generated file/i,

  // XML/HTML style
  /<auto-generated\s*\/?>/i,
  /<!-- Generated by/i,
];

// Layer 3: Language-Specific Patterns
interface LanguagePattern {
  extensions: string[];
  patterns: RegExp[];
}

const LANGUAGE_SPECIFIC: LanguagePattern[] = [
  {
    extensions: ['.go'],
    patterns: [
      // Go official specification (https://golang.org/s/generatedcode)
      /^\/\/ Code generated .* DO NOT EDIT\.$/m,
      /Code generated by protoc-gen-go/,
      /Code generated by Wire/,
      /Code generated by ent/,
      /Code generated by sqlc/,
      /Code generated by MockGen/,
      /Code generated by go-swagger/,
      /Code generated by "stringer"/,
    ],
  },
  {
    extensions: ['.js', '.ts', '.jsx', '.tsx', '.mjs', '.cjs'],
    patterns: [
      /generated using openapi-typescript-codegen/i,
      /This file was auto-generated by openapi/i,
      /Generated by orval/i,
      /THIS FILE WAS GENERATED/,
      /Generated by graphql-codegen/i,
      /Prisma Client JS/,
      /Generated by the protocol buffer/,
      /GENERATED CODE -- DO NOT EDIT/,
      /@generated SignedSource/,
      /Generated by Apollo/,
    ],
  },
  {
    extensions: ['.rb'],
    patterns: [
      /This file is auto-generated from the current state of the database/,
      /This file is autogenerated/,
      /Generated by the protocol buffer/,
      /Autogenerated by Thrift/,
      /DO NOT MODIFY.*schema/i,
    ],
  },
  {
    extensions: ['.php'],
    patterns: [
      /This class was generated by/i,
      /Doctrine .* Generated/i,
      /Generated by the protocol buffer/,
      /auto-generated by Symfony/i,
    ],
  },
  {
    extensions: ['.py'],
    patterns: [
      /Generated by the protocol buffer compiler/,
      /@generated by mypy-protobuf/,
      /Generated by the gRPC/,
      /Autogenerated by Thrift/,
      /# Generated by Django/,
      /autogenerated by sqlacodegen/i,
      /generated by datamodel-codegen/,
    ],
  },
  {
    extensions: ['.java', '.kt'],
    patterns: [
      /Generated by the protocol buffer/,
      /@javax\.annotation\.Generated/,
      /@Generated\(/,
      /Generated by the gRPC/,
      /Generated by Dagger/,
      /generated at.*by JAXB/i,
      /OpenAPI Generator/,
    ],
  },
  {
    extensions: ['.cs'],
    patterns: [
      /<auto-generated>/,
      /<autogenerated>/,
      /Generated by the protocol buffer/,
      /auto-generated by EF/i,
      /This code was generated by a tool/,
    ],
  },
];

/**
 * Checks if a file is generated.
 * Uses a 3-layer approach:
 * 1. Path/Filename patterns (fastest, no reading)
 * 2. Universal header patterns (checks first 20 lines)
 * 3. Language-specific header patterns (checks first 20 lines)
 *
 * @param parsedPath The decoded git path of the file
 * @param getHeaderLines A function that lazily provides the first 20 lines of the file content
 */
export function isGeneratedFile(
  parsedPath: string,
  getHeaderLines?: () => string[]
): GeneratedCheckResult {
  // Layer 1: Path-based check (no file read)
  // We check if the filename matches any known generated patterns
  // or if the path is in a known generated directory
  const fileName = parsedPath.split('/').pop() || '';

  for (const pattern of PATH_PATTERNS) {
    // Some patterns match the whole path (directories), others just the filename
    const textToCheck = pattern.source.includes('/') ? parsedPath : fileName;
    if (pattern.test(textToCheck)) {
      return {
        isGenerated: true,
        reason: 'path',
        matchedPattern: pattern.source,
      };
    }
  }

  // Optimization: Skip content checks for markdown files as they are documentation
  // and often contain examples of generated headers which trigger false positives.
  if (/\.(md|markdown)$/i.test(fileName)) {
    return { isGenerated: false };
  }

  // If no content provider is available, we can't check further
  if (!getHeaderLines) {
    return { isGenerated: false };
  }

  // Layer 2 & 3: Header-based check
  const lines = getHeaderLines();
  const header = lines.join('\n');

  // Universal patterns
  for (const pattern of UNIVERSAL_PATTERNS) {
    if (pattern.test(header)) {
      return {
        isGenerated: true,
        reason: 'universal',
        matchedPattern: pattern.source,
      };
    }
  }

  // Language-specific patterns
  // Simple extension extraction
  const extMatch = parsedPath.match(/\.[a-zA-Z0-9]+$/);
  const ext = extMatch ? extMatch[0] : '';

  const langPatterns = LANGUAGE_SPECIFIC.find((lang) => lang.extensions.includes(ext));

  if (langPatterns) {
    for (const pattern of langPatterns.patterns) {
      if (pattern.test(header)) {
        return {
          isGenerated: true,
          reason: 'language-specific',
          matchedPattern: pattern.source,
        };
      }
    }
  }

  return { isGenerated: false };
}
